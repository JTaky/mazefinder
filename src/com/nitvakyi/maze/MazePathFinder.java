package com.nitvakyi.maze;

import java.util.List;

public class MazePathFinder {

	private final Maze MAZE;

	public MazePathFinder(Maze maze) {
		this.MAZE = maze;
	}
	
	private void findPathes() {
		if(MAZE.getHeight() == 0 || MAZE.getWidth() == 0 || !MAZE.isRoad(0, 0)){
			log("No pathes");
			return;
		}
		List<List<? extends Point>> pathes = findPathesRecursive();
		log("Found: " + pathes);
		log("Count: " + pathes.size());
	}
	
	private List<List<? extends Point>> findPathesRecursive() {
		 return new RecursivePathFinder(MAZE).find();
		//return new IterativePathFinder(MAZE).find();
	}
	
	private void log(String msg) {
		System.out.println(msg);
	}	

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		new MazePathFinder(createMaze()).findPathes();
	}

	/*
	 * Found: 
	 * [
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 2], [3, 2], [4, 2], [4, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 2], [3, 2], [3, 3], [4, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 2], [3, 2], [3, 3], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 2], [3, 2], [3, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 2], [3, 2], [4, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 2], [2, 3], [3, 3], [4, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 2], [2, 3], [3, 3], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 2], [2, 3], [3, 3], [4, 4]],
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 2], [2, 3], [2, 4], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 2], [2, 3], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 2], [3, 3], [4, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 2], [3, 3], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 2], [3, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 3], [3, 3], [4, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 3], [3, 3], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 3], [3, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 3], [2, 4], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [1, 2], [2, 3], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [2, 2], [3, 2], [4, 2], [4, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [2, 2], [3, 2], [3, 3], [4, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [2, 2], [3, 2], [3, 3], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [2, 2], [3, 2], [3, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [2, 2], [3, 2], [4, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [2, 2], [2, 3], [3, 3], [4, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [2, 2], [2, 3], [3, 3], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [2, 2], [2, 3], [3, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [2, 2], [2, 3], [2, 4], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [2, 2], [2, 3], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [2, 2], [3, 3], [4, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [2, 2], [3, 3], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 1], [2, 2], [3, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 2], [2, 2], [3, 2], [4, 2], [4, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 2], [2, 2], [3, 2], [3, 3], [4, 3], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 2], [2, 2], [3, 2], [3, 3], [3, 4], [4, 4]], 
	 *   [ [0, 0], [0, 1], [1, 2], [2, 2], [3, 2], [3, 3], [4, 4]],
	 *   .... 
	 *   [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]]
     */
	/*
	 * x o o o o
	 * x x o o o
	 * o x x x x
	 * o o x x x
	 * o o x x x
	 */
	private static Maze createMaze() {
		Maze maze = new Maze(5, 5);
		int y = 0;
		maze.buildRoad(0, y);
		y++;
		maze.buildRoad(0, y);
		maze.buildRoad(1, y);
		y++;
		maze.buildRoad(1, y);
		maze.buildRoad(2, y);
		maze.buildRoad(3, y);
		maze.buildRoad(4, y);
		y++;
		maze.buildRoad(2, y);
		maze.buildRoad(3, y);
		maze.buildRoad(4, y);
		y++;
		maze.buildRoad(2, y);
		maze.buildRoad(3, y);
		maze.buildRoad(4, y);		
		return maze;
	}

}
